import socket
import threading
import time
import statistics
from concurrent.futures import ThreadPoolExecutor, as_completed

# ==============================================
# KONFIGURASI CLIENT 2
# ==============================================
PROXY_IP = "10.60.232.184"  # Ganti dengan IP Proxy Server (Laptop B)
PROXY_TCP_PORT = 8080
PROXY_UDP_PORT = 9090
TIMEOUT = 5
CLIENT_ID = "CLIENT-2"

# ==============================================
# TCP CLIENT - SINGLE THREAD
# ==============================================
def tcp_single_request():
    """Mengirim single TCP request ke proxy"""
    print("\n" + "="*50)
    print(f"[{CLIENT_ID}] TCP SINGLE THREAD TEST")
    print("="*50)
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(TIMEOUT)
        s.connect((PROXY_IP, PROXY_TCP_PORT))
        
        start = time.time()
        request = f"GET / HTTP/1.1\r\nHost: {CLIENT_ID}\r\n\r\n"
        s.sendall(request.encode())
        
        response = s.recv(4096).decode()
        end = time.time()
        
        print(f"âœ“ Request sent successfully")
        print(f"âœ“ Response Time: {(end - start):.4f} seconds")
        print(f"âœ“ Response Size: {len(response)} bytes")
        print(f"\nResponse Preview:\n{response[:300]}...")
        s.close()
        return end - start
    except Exception as e:
        print(f"âœ— [ERROR] {e}")
        return None

# ==============================================
# TCP CLIENT - MULTI THREAD
# ==============================================
def tcp_worker(thread_id, num_requests):
    """Worker function untuk multi-thread TCP"""
    results = []
    for i in range(num_requests):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(TIMEOUT)
            s.connect((PROXY_IP, PROXY_TCP_PORT))
            
            start = time.time()
            request = f"GET / HTTP/1.1\r\nHost: {CLIENT_ID}-T{thread_id}\r\n\r\n"
            s.sendall(request.encode())
            
            response = s.recv(4096)
            end = time.time()
            
            results.append({
                'thread_id': thread_id,
                'request_num': i,
                'response_time': end - start,
                'response_size': len(response),
                'success': True
            })
            s.close()
            print(f"  Thread-{thread_id} Request-{i+1}: {(end-start):.4f}s âœ“")
        except Exception as e:
            results.append({
                'thread_id': thread_id,
                'request_num': i,
                'error': str(e),
                'success': False
            })
            print(f"  Thread-{thread_id} Request-{i+1}: FAILED âœ—")
    return results

def tcp_multi_thread(num_threads=5, requests_per_thread=10):
    """Mengirim TCP request menggunakan multiple threads"""
    print("\n" + "="*50)
    print(f"[{CLIENT_ID}] TCP MULTI THREAD TEST")
    print("="*50)
    print(f"Threads: {num_threads}")
    print(f"Requests per thread: {requests_per_thread}")
    print(f"Total Requests: {num_threads * requests_per_thread}")
    print("\nStarting threads...")
    
    start_time = time.time()
    all_results = []
    
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        futures = [executor.submit(tcp_worker, i, requests_per_thread) 
                   for i in range(num_threads)]
        
        for future in as_completed(futures):
            all_results.extend(future.result())
    
    end_time = time.time()
    
    # Analisis hasil
    successful = [r for r in all_results if r['success']]
    failed = [r for r in all_results if not r['success']]
    
    print("\n" + "-"*50)
    print("RESULTS SUMMARY")
    print("-"*50)
    print(f"Total Duration: {(end_time - start_time):.2f} seconds")
    print(f"Successful Requests: {len(successful)}/{len(all_results)}")
    print(f"Failed Requests: {len(failed)}/{len(all_results)}")
    print(f"Success Rate: {(len(successful)/len(all_results)*100):.2f}%")
    
    if successful:
        response_times = [r['response_time'] for r in successful]
        print(f"\nResponse Time Statistics:")
        print(f"  Average: {statistics.mean(response_times):.4f} seconds")
        print(f"  Minimum: {min(response_times):.4f} seconds")
        print(f"  Maximum: {max(response_times):.4f} seconds")
        if len(response_times) > 1:
            print(f"  Std Dev: {statistics.stdev(response_times):.4f} seconds")
        print(f"  Throughput: {len(successful)/(end_time-start_time):.2f} req/sec")

# ==============================================
# UDP CLIENT - SINGLE THREAD (QoS)
# ==============================================
def udp_single_test(num_packets=50):
    """Mengirim UDP packets secara sequential - QoS Metrics"""
    print("\n" + "="*50)
    print(f"[{CLIENT_ID}] UDP SINGLE THREAD - QoS TEST")
    print("="*50)
    print(f"Sending {num_packets} UDP packets...")
    
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(1)
    
    latencies = []
    lost = 0
    
    for i in range(num_packets):
        msg = f"{CLIENT_ID}-ping-{i}".encode()
        start = time.time()
        
        try:
            s.sendto(msg, (PROXY_IP, PROXY_UDP_PORT))
            response, _ = s.recvfrom(2048)
            end = time.time()
            latencies.append(end - start)
            if (i + 1) % 10 == 0:
                print(f"  Progress: {i+1}/{num_packets} packets sent")
        except socket.timeout:
            lost += 1
    
    s.close()
    
    # Hasil QoS
    print("\n" + "-"*50)
    print("QoS METRICS")
    print("-"*50)
    print(f"Packets Sent: {num_packets}")
    print(f"Packets Received: {len(latencies)}")
    print(f"Packets Lost: {lost}")
    
    if latencies:
        avg_latency = statistics.mean(latencies)
        jitter = max(latencies) - min(latencies)
        packet_loss = (lost / num_packets) * 100
        
        print(f"\nPacket Loss: {packet_loss:.2f}%")
        print(f"\nLatency:")
        print(f"  Average: {avg_latency*1000:.2f} ms")
        print(f"  Minimum: {min(latencies)*1000:.2f} ms")
        print(f"  Maximum: {max(latencies)*1000:.2f} ms")
        print(f"\nJitter: {jitter*1000:.2f} ms")
        
        # Kategorisasi QoS
        if packet_loss < 1:
            qos_rating = "Excellent"
        elif packet_loss < 5:
            qos_rating = "Good"
        elif packet_loss < 10:
            qos_rating = "Fair"
        else:
            qos_rating = "Poor"
        
        print(f"\nQoS Rating: {qos_rating}")
    else:
        print(f"\nPacket Loss: 100.00% (0/{num_packets} received)")
        print("QoS Rating: Failed")

# ==============================================
# UDP CLIENT - MULTI THREAD
# ==============================================
def udp_worker(thread_id, num_packets):
    """Worker function untuk multi-thread UDP"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(1)
    
    results = {
        'thread_id': thread_id,
        'latencies': [],
        'lost': 0
    }
    
    for i in range(num_packets):
        msg = f"{CLIENT_ID}-T{thread_id}-ping-{i}".encode()
        start = time.time()
        
        try:
            s.sendto(msg, (PROXY_IP, PROXY_UDP_PORT))
            response, _ = s.recvfrom(2048)
            end = time.time()
            results['latencies'].append(end - start)
        except socket.timeout:
            results['lost'] += 1
    
    s.close()
    print(f"  Thread-{thread_id} completed: {len(results['latencies'])}/{num_packets} received")
    return results

def udp_multi_thread(num_threads=5, packets_per_thread=20):
    """Mengirim UDP packets menggunakan multiple threads"""
    print("\n" + "="*50)
    print(f"[{CLIENT_ID}] UDP MULTI THREAD TEST")
    print("="*50)
    print(f"Threads: {num_threads}")
    print(f"Packets per thread: {packets_per_thread}")
    print(f"Total Packets: {num_threads * packets_per_thread}")
    print("\nStarting threads...")
    
    start_time = time.time()
    all_results = []
    
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        futures = [executor.submit(udp_worker, i, packets_per_thread) 
                   for i in range(num_threads)]
        
        for future in as_completed(futures):
            all_results.append(future.result())
    
    end_time = time.time()
    
    # Agregasi hasil
    all_latencies = []
    total_lost = 0
    total_packets = num_threads * packets_per_thread
    
    for result in all_results:
        all_latencies.extend(result['latencies'])
        total_lost += result['lost']
    
    # Hasil QoS
    print("\n" + "-"*50)
    print("QoS METRICS")
    print("-"*50)
    print(f"Total Duration: {(end_time - start_time):.2f} seconds")
    print(f"Packets Sent: {total_packets}")
    print(f"Packets Received: {len(all_latencies)}")
    print(f"Packets Lost: {total_lost}")
    
    if all_latencies:
        avg_latency = statistics.mean(all_latencies)
        jitter = max(all_latencies) - min(all_latencies)
        packet_loss = (total_lost / total_packets) * 100
        
        print(f"\nPacket Loss: {packet_loss:.2f}%")
        print(f"\nLatency:")
        print(f"  Average: {avg_latency*1000:.2f} ms")
        print(f"  Minimum: {min(all_latencies)*1000:.2f} ms")
        print(f"  Maximum: {max(all_latencies)*1000:.2f} ms")
        print(f"\nJitter: {jitter*1000:.2f} ms")
        print(f"\nThroughput: {len(all_latencies)/(end_time-start_time):.2f} packets/sec")
    else:
        print(f"\nPacket Loss: 100.00% (0/{total_packets} received)")

# ==============================================
# TCP STRESS TEST - CONCURRENT CONNECTIONS
# ==============================================
def tcp_stress_test(num_connections=50, duration=10):
    """Stress test dengan banyak koneksi concurrent"""
    print("\n" + "="*50)
    print(f"[{CLIENT_ID}] TCP STRESS TEST")
    print("="*50)
    print(f"Target Concurrent Connections: {num_connections}")
    print(f"Duration: {duration} seconds")
    print("\nEstablishing connections...")
    
    results = {'success': 0, 'failed': 0, 'errors': []}
    
    def keep_alive_connection(conn_id):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(TIMEOUT)
            s.connect((PROXY_IP, PROXY_TCP_PORT))
            
            time.sleep(duration)
            
            s.close()
            results['success'] += 1
            if (conn_id + 1) % 10 == 0:
                print(f"  {conn_id + 1}/{num_connections} connections established")
        except Exception as e:
            results['failed'] += 1
            results['errors'].append(str(e))
    
    start_time = time.time()
    threads = []
    
    for i in range(num_connections):
        t = threading.Thread(target=keep_alive_connection, args=(i,))
        t.start()
        threads.append(t)
        time.sleep(0.01)
    
    for t in threads:
        t.join()
    
    end_time = time.time()
    
    print("\n" + "-"*50)
    print("STRESS TEST RESULTS")
    print("-"*50)
    print(f"Test Duration: {(end_time - start_time):.2f} seconds")
    print(f"Successful Connections: {results['success']}/{num_connections}")
    print(f"Failed Connections: {results['failed']}/{num_connections}")
    print(f"Success Rate: {(results['success']/num_connections)*100:.2f}%")

# ==============================================
# MENU UTAMA
# ==============================================
def main():
    print("\n" + "="*50)
    print(f"  {CLIENT_ID} - ENHANCED TESTING SUITE")
    print("="*50)
    print("\nðŸ“‹ Available Tests:")
    print("\n  TCP Tests:")
    print("    1. TCP Single Thread")
    print("    2. TCP Multi Thread")
    print("    3. TCP Stress Test")
    print("\n  UDP Tests:")
    print("    4. UDP Single Thread (QoS)")
    print("    5. UDP Multi Thread")
    print("\n  Combined:")
    print("    6. Run All Tests")
    print("\n    0. Exit")
    
    choice = input("\nâž¤ Select test [0-6]: ")
    
    if choice == "1":
        tcp_single_request()
    elif choice == "2":
        threads = int(input("  Number of threads [default: 5]: ") or "5")
        requests = int(input("  Requests per thread [default: 10]: ") or "10")
        tcp_multi_thread(threads, requests)
    elif choice == "3":
        connections = int(input("  Concurrent connections [default: 50]: ") or "50")
        duration = int(input("  Duration in seconds [default: 10]: ") or "10")
        tcp_stress_test(connections, duration)
    elif choice == "4":
        packets = int(input("  Number of packets [default: 50]: ") or "50")
        udp_single_test(packets)
    elif choice == "5":
        threads = int(input("  Number of threads [default: 5]: ") or "5")
        packets = int(input("  Packets per thread [default: 20]: ") or "20")
        udp_multi_thread(threads, packets)
    elif choice == "6":
        print("\nðŸš€ Running comprehensive test suite...\n")
        tcp_single_request()
        time.sleep(1)
        tcp_multi_thread(3, 5)
        time.sleep(1)
        udp_single_test(30)
        time.sleep(1)
        udp_multi_thread(3, 10)
    elif choice == "0":
        print("\nðŸ‘‹ Exiting...")
        return
    else:
        print("\nâŒ Invalid choice!")
        return
    
    # Tanya apakah mau test lagi
    print("\n" + "="*50)
    again = input("Run another test? [y/n]: ")
    if again.lower() == 'y':
        main()

if __name__ == "__main__":
    print("\n" + "="*50)
    print("  âš ï¸  PRE-FLIGHT CHECKLIST")
    print("="*50)
    print(f"  âœ“ PROXY_IP: {PROXY_IP}")
    print(f"  âœ“ TCP Port: {PROXY_TCP_PORT}")
    print(f"  âœ“ UDP Port: {PROXY_UDP_PORT}")
    print("\n  Make sure:")
    print("  1. Proxy server is running on Laptop B")
    print("  2. Web server is running on Laptop A")
    print("  3. Network connection is stable")
    
    input("\nPress ENTER to continue...")
    main()
